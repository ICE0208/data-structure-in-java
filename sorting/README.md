# Sorting

## 목차

### 기본 정렬

- [선택 정렬](#selection)
- [버블 정렬](#bubble)
- 삽입 정렬

### 고급 정렬

- [병합 정렬](#merge)
- [퀵 정렬](#quick)
- 힙 정렬
- 셸 정렬

### 특수 정렬

- 계수 정렬
- 기수 정렬
- 버킷 정렬

---

<br/>

## <span id="selection">선택 정렬 / Selection Sort</span>

> 선택 정렬은 배열의 요소 중 가장 작은(또는 가장 큰) 요소를 반복적으로 선택하여 목록의 정렬된 부분으로 이동하는 방식으로 작동하는 간단하고 효율적인 알고리즘이다.
> g

### 로직

1. 주어진 리스트 중에 최대값을 찾는다.
2. 그 값을 맨 뒤에 위치한 값과 교체한다
3. 맨 마지막 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.

### 수도 코드

```
selectionSort(A[], n):
    for last <- n-1 downTo 1
        A[0...last] 중 가장 큰 수 A[k]를 찾는다
        A[k] <-> A[last]
```

### 장점

정렬을 위한 비교 횟수는 많지만 교환 횟수가 적기 때문에 교환이 많이 이루어져야 하는 상황에서 효율적으로 사용될 수 있다. (내림차순 to 오름차순)

### 단점

정렬을 위한 비교 횟수가 많으며, $O(N^2)$이라는 시간 복잡도를 갖기 때문에 많은 데이터를 정렬해야 하는 경우에 불리하다.

---

<br/>

## <span id="bubble">버블 정렬 / Bubble Sort</span>

> 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘이다. 선택 정렬과 유사하다.

### 로직

1. 요소들을 첫 번째 요소부터 차례로 바로 다음 원소와 비교하면서 앞에 있는 원소가 더 크다면 두 요소의 위치를 교환한다.
2. 가장 오른쪽으로 이동한 원소를 제외한 요소들을 대상으로 반복한다.

### 수도 코드

```
bubbleSort(A[]):
    n <- arr.length
    for last <- n-1 downto 1
        for i <- 0 to last-1
            if (A[i]) > A[i+1]
                A[i] <-> A[i+1]
```

### 장점

구현이 매우 간단하고 소스코드가 직관적이다. 또한 제자리 정렬이기 때문에 공간 복잡도 측면에서 유리하다.

### 단점

시간 복잡도가 $O(N^2)$으로 굉장히 비효율적이다.

---

<br/>

## <span id="merge">병합 정렬 / Merge Sort</span>

> 병합 정렬은 배열을 더 작은 하위 배열로 나누고 각 하위 배열을 정렬한 다음 정렬된 하위 배열을 다시 병합하여 최종 정렬된 배열을 형성하는 정렬 알고리즘이다.

### 로직

1. 리스트의 길이가 1 이하일 경우, 정렬이 불필요하므로 그대로 리스트를 반환한다.
2. 리스트를 절반으로 나눠서 왼쪽 부분과 오른쪽 부분으로 분할한다.
3. 재귀를 사용하여 왼쪽 부분과 오른쪽 부분 각각에 대해 병합 정렬을 수행한다.
4. 정렬된 왼쪽 부분과 정렬된 오른쪽 부분을 합친다.

### 수도 코드

```
mergeSort(A[], p, r):
    if(p < r)
        q <- [(p+r)/2]
        mergeSort(A, p, q)
        mergeSort(A, q+1, r)
        merge(A, p, q, r)
```

### 병합 로직

1. 병합할 각 배열의 첫 번째 원소부터 마지막 원소까지 순서대로 비교하며 작은 원소를 임시 배열에 추가한다.
2. 한쪽 배열이 더 커서 임시 배열에 추가되지 않은 원소들이 있다면 순서대로 임시 배열에 추가한다.
3. 병합한 범위에 대하여 임시 배열의 원소를 원본 배열에 복사한다.

### 병합 수도 코드

```
merge(A[], p, q, r):
    i <- p; j <- q+1; t <- 0
    while (i <= q and j <= r)
        if (A[i] <= A[j]) tmp[t++] <- A[i++]
        else tmp[t++] <- A[j++]
    while (i <= q)
        tmp[t++] <- A[i++]
    while (j <= r)
        tmp[t++] <- A[j++]
    i <- p; t <- 0
    while (i <= r)
        A[i++] <- tmp[t++]
```

### 장점

무조건 절반씩 분할해가면서 정렬하기 때문에 항상 $O(N * logN)$의 시간 복잡도를 보장한다.

### 단점

병할을 진행할 때 임시 배열을 사용하기 때문에 추가적인 메모리가 필요하다는 단점이 있다.

---

<br/>

## <span id="quick">퀵 정렬 / Quick Sort</span>

> 임의의 원소를 기준으로 잡아 기준 원소보다 작은 원소와 큰 원소 그룹으로 나누어 기준 원소의 좌우로 분할한 다음 각각을 정렬하는 알고리즘이다.

### 로직

1. 임의의 원소를 선택하여 pivot으로 지정한다. (여기서는 마지막 원소)
2. pivot을 기준으로 pivot보다 작은 요소들은 모두 pivot의 왼쪽에, 큰 요소들은 모두 pivot의 오른쪽으로 옮겨진다.
3. pivot을 제외한 왼쪽 부분과 오른쪽 부분을 다시 정렬한다. (재귀적 호출)
4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.

### 수도 코드

```
quickSort(A[], p, r):
    if (p < r)
        q <- partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)
```

### 분할 로직

1. 마지막 원소를 pivot으로 지정한다.
2. 배열을 처음부터 마지막 원소 전까지 조사하면서 원소가 pivot보다 작은 경우 왼쪽 부분으로 이동시킨다.
3. pivot을 왼쪽 부분과 오른쪽 부분 사이로 이동시킨다.

### 분할 수도 코드

```
partition(A[], p, r):
    x <- A[r]
    i <- p-1
    for j <- p to r-1
        if (A[j] < x>)
            A[++i] <-> A[j]
    A[i+1] <-> A[r]
    return i+1
```

### 장점

일반적인 상황에서 평균적으로 $O(N*logN)$의 시간이 소요되어 매우 빠르게 정렬할 수 있다. 또한 재귀 호출에 의한 스택 메모리를 제외하고 추가적인 메모리가 거의 필요하지 않다.

### 단점

이미 정렬되어 있거나 거의 정렬되어있는 경우, 또한 동일한 원소가 많이 존재하는 경우 시간이 오래걸린다. 최악의 경우 $O(N^2)$의 시간이 소요된다.

---

<br/>
